## API Report File for "polyethylene"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type AsyncChunkingPredicate<T> = (elem: T, lastElem: T, firstElem: T) => boolean | PromiseLike<boolean>;

// @public
export type AsyncIndexedMapping<T, U> = (elem: T, index: number) => U | PromiseLike<U>;

// @public
export type AsyncIndexedPredicate<T> = (elem: T, index: number) => boolean | PromiseLike<boolean>;

// @public
export type AsyncIndexedReducer<T, U> = (acc: U, item: T, index: number) => U | PromiseLike<U>;

// @public
export type AsyncIndexedRunnable<T> = (elem: T, index: number) => void | PromiseLike<void>;

// @public
export class AsyncIterableBuilder<T> implements AsyncIterable<T> {
    [Symbol.asyncIterator](): AsyncIterator<T>;
    // @internal
    constructor();
    done(): void;
    error(error: Error): void;
    toPolyAsyncIterable(): PolyAsyncIterable<T>;
    value(obj: T): void;
}

// @public
export type ChunkingPredicate<T> = (elem: T, lastElem: T, firstElem: T) => boolean;

// @public
export type Comparator<T> = (elemA: T, elemB: T) => number;

// @public
export interface ConcurrencyOptions {
    bufferSize?: number;
    concurrency?: number;
}

// @public
export type IndexedMapping<T, U> = (elem: T, index: number) => U;

// @public
export type IndexedPredicate<T> = (elem: T, index: number) => boolean;

// @public
export type IndexedReducer<T, U> = (acc: U, item: T, index: number) => U;

// @public
export type IndexedRunnable<T> = (elem: T, index: number) => void;

// @public
export type IndexedTypePredicate<T, U extends T> = (elem: T, index: number) => elem is U;

// @public
namespace Poly {
    function asyncFrom<T>(iterableOrFactory: Iterable<T> | IterableFactory<T> | AsyncIterable<T> | AsyncIterableFactory<T>): PolyAsyncIterable<T>;
    type AsyncIterableFactory<T> = () => AsyncIterable<T>;
    function asyncIterate<T>(func: (lastValue: T | undefined) => T | Promise<T>): PolyAsyncIterable<T>;
    function asyncIterate<T>(func: (lastValue: T) => T | Promise<T>, initValue: T): PolyAsyncIterable<T>;
    function builder<T>(): AsyncIterableBuilder<T>;
    function buildWith<T>(func: (builder: AsyncIterableBuilder<T>) => void): PolyAsyncIterable<T>;
    function empty<T = never>(): PolySyncIterable<T>;
    function entries<K extends PropertyKey, V>(obj: Record<K, V>): PolySyncIterable<[K, V]>;
    function from<T>(iterableOrFactory: AsyncIterable<T> | AsyncIterableFactory<T>): PolyAsyncIterable<T>;
    function from<T>(iterableOrFactory: Iterable<T> | IterableFactory<T>): PolySyncIterable<T>;
    function from<T>(iterableOrFactory: Iterable<T> | IterableFactory<T> | AsyncIterable<T> | AsyncIterableFactory<T>): PolySyncIterable<T> | PolyAsyncIterable<T>;
    type IterableFactory<T> = () => Iterable<T>;
    function keys<K extends PropertyKey>(obj: Record<K, unknown>): PolySyncIterable<K>;
    function range(to: number): PolySyncIterable<number>;
    function range(from: number, to: number): PolySyncIterable<number>;
    function range(from: number, to: number, step?: number): PolySyncIterable<number>;
    function repeat<T>(value: T): PolySyncIterable<T>;
    function syncFrom<T>(iterableOrFactory: Iterable<T> | IterableFactory<T>): PolySyncIterable<T>;
    function syncIterate<T>(func: (lastValue: T | undefined) => T): PolySyncIterable<T>;
    function syncIterate<T>(func: (lastValue: T) => T, initValue: T): PolySyncIterable<T>;
    function values<V, K extends PropertyKey = PropertyKey>(obj: Record<K, V>): PolySyncIterable<V>;
}
export { Poly }
export default Poly;

// @public
export class PolyAsyncIterable<T> implements AsyncIterable<T> {
    [Symbol.asyncIterator](): AsyncIterator<T, any, any>;
    // @internal
    constructor(iterable: AsyncIterable<T>);
    append<U>(other: Iterable<U> | AsyncIterable<U>): PolyAsyncIterable<T | U>;
    async(): PolyAsyncIterable<T>;
    chunk(num: number): PolyAsyncIterable<Array<T>>;
    chunkWhile(func: AsyncChunkingPredicate<T>): PolyAsyncIterable<Array<T>>;
    complete(options?: ConcurrencyOptions): Promise<void>;
    concat<U>(other: Iterable<U> | AsyncIterable<U>): PolyAsyncIterable<T | U>;
    count(): Promise<number>;
    drop(num: number): PolyAsyncIterable<T>;
    dropLast(num: number): PolyAsyncIterable<T>;
    dropWhile(func: AsyncIndexedPredicate<T>): PolyAsyncIterable<T>;
    duplicate<N extends number>(num: N): Tuple<PolyAsyncIterable<T>, N>;
    every(func: AsyncIndexedPredicate<T>, options?: ConcurrencyOptions): Promise<boolean>;
    filter<U extends T>(func: IndexedTypePredicate<T, U>, options?: ConcurrencyOptions): PolyAsyncIterable<U>;
    filter(func: AsyncIndexedPredicate<T>, options?: ConcurrencyOptions): PolyAsyncIterable<T>;
    filterNotNullish(): PolyAsyncIterable<NonNullable<T>>;
    find<U extends T>(func: IndexedTypePredicate<T, U>, options?: ConcurrencyOptions): Promise<U | undefined>;
    find(func: AsyncIndexedPredicate<T>, options?: ConcurrencyOptions): Promise<T | undefined>;
    findIndex(func: AsyncIndexedPredicate<T>, options?: ConcurrencyOptions): Promise<number>;
    findLast<U extends T>(func: IndexedTypePredicate<T, U>, options?: ConcurrencyOptions): Promise<U | undefined>;
    findLast(func: AsyncIndexedPredicate<T>, options?: ConcurrencyOptions): Promise<T | undefined>;
    findLastIndex(func: AsyncIndexedPredicate<T>, options?: ConcurrencyOptions): Promise<number>;
    flat<U>(this: PolyAsyncIterable<Iterable<U> | AsyncIterable<U>>): PolyAsyncIterable<U>;
    flatMap<U>(func: AsyncIndexedMapping<T, Iterable<U> | AsyncIterable<U>>, options?: ConcurrencyOptions): PolyAsyncIterable<U>;
    flatten<U>(this: PolyAsyncIterable<Iterable<U> | AsyncIterable<U>>): PolyAsyncIterable<U>;
    forEach(func: AsyncIndexedRunnable<T>, options?: ConcurrencyOptions): Promise<void>;
    groupBy<K>(func: AsyncIndexedMapping<T, K>, options?: ConcurrencyOptions): PolyAsyncIterable<[K, Array<T>]>;
    includes(obj: T): Promise<boolean>;
    join(glue?: string, options?: ConcurrencyOptions): Promise<string>;
    map<U>(func: AsyncIndexedMapping<T, U>, options?: ConcurrencyOptions): PolyAsyncIterable<U>;
    mapKeys<K1, K2, V>(this: PolyAsyncIterable<[K1, V]>, func: AsyncIndexedMapping<[K1, V], K2>, options?: ConcurrencyOptions): PolyAsyncIterable<[K2, V]>;
    mapValues<K, V1, V2>(this: PolyAsyncIterable<[K, V1]>, func: AsyncIndexedMapping<[K, V1], V2>, options?: ConcurrencyOptions): PolyAsyncIterable<[K, V2]>;
    prefetch(): PolyAsyncIterable<T>;
    prepend<U>(other: Iterable<U> | AsyncIterable<U>): PolyAsyncIterable<T | U>;
    reduce(reducer: AsyncIndexedReducer<T, T>, init?: T): Promise<T>;
    reduce<U>(reducer: AsyncIndexedReducer<T, U>, init: U): Promise<U>;
    reverse(): PolyAsyncIterable<T>;
    slice(start: number, end?: number): PolyAsyncIterable<T>;
    some(func: AsyncIndexedPredicate<T>, options?: ConcurrencyOptions): Promise<boolean>;
    sort(func?: Comparator<T>): PolyAsyncIterable<T>;
    take(num: number): PolyAsyncIterable<T>;
    takeLast(num: number): PolyAsyncIterable<T>;
    takeWhile<U extends T>(func: IndexedTypePredicate<T, U>): PolyAsyncIterable<U>;
    takeWhile(func: AsyncIndexedPredicate<T>): PolyAsyncIterable<T>;
    tap(func: AsyncIndexedRunnable<T>, options?: ConcurrencyOptions): PolyAsyncIterable<T>;
    toArray(): Promise<Array<T>>;
    toMap<K, V>(this: PolyAsyncIterable<[K, V] | readonly [K, V]>): Promise<Map<K, V>>;
    toObject<K extends PropertyKey, V>(this: PolyAsyncIterable<[K, V] | readonly [K, V]>): Promise<Record<K, V>>;
    toPartitionArrays<U extends T>(func: IndexedTypePredicate<T, U>, options?: ConcurrencyOptions): Promise<[Array<U>, Array<Exclude<T, U>>]>;
    toPartitionArrays(func: AsyncIndexedPredicate<T>, options?: ConcurrencyOptions): Promise<[Array<T>, Array<T>]>;
    unique(func?: AsyncIndexedMapping<T, unknown>, options?: ConcurrencyOptions): PolyAsyncIterable<T>;
}

// @public
export abstract class PolySyncIterable<T> implements Iterable<T> {
    abstract [Symbol.iterator](): Iterator<T>;
    append<U>(other: Iterable<U>): PolySyncIterable<T | U>;
    async(): PolyAsyncIterable<T>;
    chunk(num?: number): PolySyncIterable<Array<T>>;
    chunkWhile(func: ChunkingPredicate<T>): PolySyncIterable<Array<T>>;
    complete(): void;
    concat<U>(other: Iterable<U>): PolySyncIterable<T | U>;
    count(): number;
    drop(num?: number): PolySyncIterable<T>;
    dropLast(num?: number): PolySyncIterable<T>;
    dropWhile(func: IndexedPredicate<T>): PolySyncIterable<T>;
    duplicate<N extends number>(num: N): Tuple<PolySyncIterable<T>, N>;
    every(func: IndexedPredicate<T>): boolean;
    filter<U extends T>(func: IndexedTypePredicate<T, U>): PolySyncIterable<U>;
    filter(func: IndexedPredicate<T>): PolySyncIterable<T>;
    filterNotNullish(): PolySyncIterable<NonNullable<T>>;
    find<U extends T>(func: IndexedTypePredicate<T, U>): U | undefined;
    find(func: IndexedPredicate<T>): T | undefined;
    findIndex(func: IndexedPredicate<T>): number;
    findLast<U extends T>(func: IndexedTypePredicate<T, U>): U | undefined;
    findLast(func: IndexedPredicate<T>): T | undefined;
    findLastIndex(func: IndexedPredicate<T>): number;
    flat<U>(this: PolySyncIterable<Iterable<U>>): PolySyncIterable<U>;
    flatMap<U>(func: IndexedMapping<T, Iterable<U>>): PolySyncIterable<U>;
    flatten<U>(this: PolySyncIterable<Iterable<U>>): PolySyncIterable<U>;
    forEach(func: IndexedRunnable<T>): void;
    groupBy<K>(func: IndexedMapping<T, K>): PolySyncIterable<[K, Array<T>]>;
    includes(obj: T): boolean;
    join(glue?: string): string;
    map<U>(func: IndexedMapping<T, U>): PolySyncIterable<U>;
    mapKeys<K1, K2, V>(this: PolySyncIterable<[K1, V]>, func: IndexedMapping<[K1, V], K2>): PolySyncIterable<[K2, V]>;
    mapValues<K, V1, V2>(this: PolySyncIterable<[K, V1]>, func: IndexedMapping<[K, V1], V2>): PolySyncIterable<[K, V2]>;
    prepend<U>(other: Iterable<U>): PolySyncIterable<T | U>;
    reduce(reducer: IndexedReducer<T, T>, init?: T): T;
    reduce<U>(reducer: IndexedReducer<T, U>, init: U): U;
    reverse(): PolySyncIterable<T>;
    slice(start: number, end?: number): PolySyncIterable<T>;
    some(func: IndexedPredicate<T>): boolean;
    sort(func?: Comparator<T>): PolySyncIterable<T>;
    take(num?: number): PolySyncIterable<T>;
    takeLast(num?: number): PolySyncIterable<T>;
    takeWhile<U extends T>(func: IndexedTypePredicate<T, U>): PolySyncIterable<U>;
    takeWhile(func: IndexedPredicate<T>): PolySyncIterable<T>;
    tap(func: IndexedRunnable<T>): PolySyncIterable<T>;
    toArray(): Array<T>;
    toMap<K, V>(this: PolySyncIterable<[K, V] | readonly [K, V]>): Map<K, V>;
    toObject<K extends PropertyKey, V>(this: PolySyncIterable<[K, V] | readonly [K, V]>): Record<K, V>;
    toPartitionArrays<U extends T>(func: IndexedTypePredicate<T, U>): [Array<U>, Array<Exclude<T, U>>];
    toPartitionArrays(func: IndexedPredicate<T>): [Array<T>, Array<T>];
    unique(func?: IndexedMapping<T, unknown>): PolySyncIterable<T>;
}

// @public
export type Tuple<T, N extends number> = [T, ...T[]] & {
    length: N;
};

```
